package example05
public
	with Zero_Slack_Scheduling;

-----------------------------------------------------------------------
-- begin datatype stuff
-----------------------------------------------------------------------

-- a (X,Y) pair denoting a cell coordinate
data coordinate
end coordinate;

-- index to access an element in a multi-dimensional array
data element_index
end element_index;

-- a lock
data lock_type
end lock_type;

-- declaration of array of locks
data locks_array_type	
end locks_array_type;

-- implementation of array of locks
data implementation locks_array_type.i
subcomponents
  locks: data lock_type[5];
end locks_array_type.i;	

-- declaration of lock update
data lock_update_type
end lock_update_type;

-- implementation of lock update
data implementation lock_update_type.i
subcomponents
  lock: data lock_type;
  index: data element_index;		
end lock_update_type.i;

-- initialized node
data initialized_node_type
end initialized_node_type;	

-- declaration of initialized node update type
data initialized_node_update_type
end initialized_node_update_type;

-- implementation of initialized node update type
data implementation initialized_node_update_type.i
subcomponents
  initialized_node: data initialized_node_type;
  index: data element_index;
end initialized_node_update_type.i;

subprogram set_lock_routine_type
end set_lock_routine_type;	

subprogram set_leader_destination_routine_type
end set_leader_destination_routine_type;

subprogram set_initialized_routine_type
end set_initialized_routine_type;

subprogram getlocks_routine_type
end getlocks_routine_type;

subprogram get_leader_destination_routine_type
end get_leader_destination_routine_type;

subprogram set_waypoint_routine_type
end set_waypoint_routine_type;

subprogram get_waypoint_routine_type
end get_waypoint_routine_type;

-- declaration of distributed data store
data distributed_data_store
	features
		setlock: provides subprogram access set_lock_routine_type; 
		setleaderdestination: provides subprogram access set_leader_destination_routine_type;
		setinitialized: provides subprogram access set_initialized_routine_type;	
		getlocks: provides subprogram access getlocks_routine_type;	
		getleaderdestination: provides subprogram access get_leader_destination_routine_type;
		setwaypoint: provides subprogram access set_waypoint_routine_type;
		getwaypoint: provides subprogram access get_waypoint_routine_type;
end distributed_data_store;

-- implementation of distributed data store
data implementation distributed_data_store.i
subcomponents
  setlockprogram: subprogram set_lock_routine_type;
  setleaderdestinationprogram: subprogram set_leader_destination_routine_type;
  setinitializedprogram: subprogram set_initialized_routine_type;
  locks: data locks_array_type.i;
  destination: data coordinate[1];
  initalized_nodes: data initialized_node_type[5];
end distributed_data_store.i;

-----------------------------------------------------------------------
-- end datatype stuff
-----------

processor dart_processor
end dart_processor;

-- the MADARA receiver thread declaration
thread madara_receiver_thread
features
  leader_destination_update: in data port coordinate;
  lock_update_in: in  data port lock_update_type.i;
  init_update: in  data port initialized_node_update_type.i;
  --distributed_variables: out data port distributed_data_store.i;
  setlock : requires subprogram access set_lock_routine_type;
  setleaderdestination: requires subprogram access set_leader_destination_routine_type;
  setinitialized: requires subprogram access set_initialized_routine_type;  
end madara_receiver_thread;

process dart_sw
	features
		lock_update_in: in data port lock_update_type.i;
		leader_destination_update: in data port coordinate;
end dart_sw;
		
process implementation dart_sw.i
	subcomponents
		distributed_store: data distributed_data_store.i;
		madara_thread: thread madara_receiver_thread;
	connections
		c1: subprogram access madara_thread.setlock -> distributed_store.setlock;
		c2: subprogram access madara_thread.setleaderdestination -> distributed_store.setleaderdestination;
		c3: subprogram access madara_thread.setinitialized -> distributed_store.setinitialized;		
		c4: port lock_update_in -> madara_thread.lock_update_in;	
		c5: port leader_destination_update->madara_thread.leader_destination_update;	
end dart_sw.i;

thread collision_avoidance
	features 
		getlocks: requires subprogram access getlocks_routine_type;
		setlock: requires subprogram access set_lock_routine_type;
		publish_lock: out data port lock_update_type.i; -- CHECK if event or only data
		get_waypoint: requires subprogram access get_waypoint_routine_type;
end collision_avoidance;

thread waypoint_thread
	features
		get_leader_destination : requires subprogram access get_leader_destination_routine_type;
		set_waypoint: requires subprogram access set_waypoint_routine_type;
end waypoint_thread;

process protector_sw extends dart_sw
	features
		publish_lock : out data port lock_update_type.i;
end protector_sw;

process implementation protector_sw.i extends dart_sw.i
	subcomponents
		avoidance: thread  collision_avoidance;
		waypoint: thread waypoint_thread;
	connections
		c10: subprogram access avoidance.getlocks->distributed_store.getlocks;	
		c11: subprogram access avoidance.setlock->distributed_store.setlock;
		c12: port avoidance.publish_lock->	publish_lock;
		c13: subprogram access waypoint.get_leader_destination -> distributed_store.getleaderdestination;
		c14: subprogram access waypoint.set_waypoint -> distributed_store.setwaypoint;
		c15: subprogram access avoidance.get_waypoint -> distributed_store.getwaypoint;
end protector_sw.i;

system protector_node
	features
		publish_lock: out data port lock_update_type.i;
		leader_destination: in data port coordinate;
		input_lock: in data port lock_update_type.i;
end protector_node;

system implementation protector_node.i
	subcomponents
		hw: processor dart_processor;
		sw: process protector_sw.i;
	connections
		c1: port input_lock->sw.lock_update_in;
		c2: port sw.publish_lock -> publish_lock;
		c3: port leader_destination -> sw.leader_destination_update;
	properties
		Actual_Processor_Binding => (reference (hw)) applies to sw;
end protector_node.i;	

thread leader_navigation
	features
		setleaderdestination: requires subprogram access set_leader_destination_routine_type;
		leader_destination: out data port coordinate;
end leader_navigation;

thread implementation leader_navigation.i 
end leader_navigation.i;

process leader_sw extends dart_sw
	features
		leader_destination: out data port coordinate;
		publish_lock: out data port lock_update_type.i;
end leader_sw;

process implementation leader_sw.i extends dart_sw.i
	subcomponents
		navigation: thread leader_navigation.i;
		avoidance: thread collision_avoidance;
	connections
		c20: subprogram access navigation.setleaderdestination->distributed_store.setleaderdestination;
		c21: port navigation.leader_destination -> leader_destination; 
		c23: subprogram access avoidance.setlock->distributed_store.setlock;
		c24: port avoidance.publish_lock->	publish_lock;		
		c25: subprogram access avoidance.getlocks->distributed_store.getlocks;	
end leader_sw.i;
	
system leader_node
	features
		leader_destination : out data port coordinate;
		publish_lock : out data port lock_update_type.i;
		input_lock : in data port lock_update_type.i;
end leader_node;

system implementation leader_node.i
	subcomponents
		hw: processor dart_processor;
		sw: process leader_sw.i;
	connections
		c1: port sw.leader_destination -> leader_destination;
		c2: port sw.publish_lock -> publish_lock;
		c3: port input_lock->sw.lock_update_in;
	properties
		Actual_Processor_Binding => (reference (hw)) applies to sw;	
end leader_node.i;	
	
system protector_swarm
end protector_swarm;	
	
system implementation protector_swarm.i
	subcomponents
		leader: system leader_node.i;
		protectors: system protector_node.i[4];
	connections
		c1: port leader.leader_destination->protectors.leader_destination {Connection_Pattern =>((One_to_All));};
		c2: port leader.publish_lock -> protectors.input_lock {Connection_Pattern => ((One_to_All));};
		c3: port protectors.publish_lock->leader.input_lock{Connection_Pattern => ((All_to_One));};
		c4: port protectors.publish_lock->protectors.input_lock {Connection_Pattern => ((All_to_All));};
end protector_swarm.i;	
	
end example05;