//-- an example with 5 nodes -- a leader in the middle and four
//-- protectors surrounding it. the leader moves from an initial to a
//-- target coordinate, going from one waypoint to the next following
//-- a path planning strategy. the protectors try to follow the
//-- leader's movement and keep it surrounded. each node has three
//-- threads -- a synchronous thread responsible for moving to the
//-- next waypoint avoiding collisions, an asynchronous thread that
//-- determines the next waypoint for the node, and an asynchronous
//-- adaptation manager thread that switched formation between tight
//-- and loose. the timing characteristics for various thread
//-- (periods, WCETs etc.) are specified in a separate DMPL file.

target GNU_CPP,WIN_CPP %%{
#define GNU_WIN
#include <stdlib.h>
#include <math.h>
#include <sys/resource.h>
#include <map>
#include "madara/utility/Utility.h"
#include "./adaptation_manager.h"
#include "./dartam/adaptation_manager.h"
  
double accumulated_risk = 0.0;

std::map<int,std::map<int,double> > hazard_map;

void INIT_HAZARDS(int _X, int _Y, int tx, int ty)
{
  for(int x = 0; x < _X; x++)
  {
    for(int y = 0; y < _Y; y++)
    {
      if(x == tx && y == ty)
      {
        hazard_map[x][y] = 0;
      }
      else if(x > 4 && y <= 4)
      {
        hazard_map[x][y] = (rand() * 1.0 / RAND_MAX) * 0.4 + 0.5;
      }
      else
      {
        hazard_map[x][y] = (rand() * 1.0 / RAND_MAX) * 0.4;
      }
    }
  }
}

double GET_HAZARD(int x, int y)
{
  return hazard_map[x][y];
}

double accumulate_risk(double risk)
{
  printf("Risk: %f (+%f)\n", accumulated_risk, risk);
  return accumulated_risk += risk;
}

int MOVE_TO(unsigned char x,unsigned char y)
{
  return rand() < (RAND_MAX / 10 * 6);
}

int my_sleep (int seconds)
{
  Madara::Utility::sleep (seconds);
  return 0;
}

//-- return the current wall time since epoch
double wall_time()
{
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return tv.tv_sec + 0.000001 * tv.tv_usec;
}
 
int round = 0;
int xi,yi;

void print_int(int i)
{
  printf("%i\n", i);
}

void print_labeled_int(int i)
{
  printf("ADAPTATION_MANAGER_OUTPUT : %d\n", i);
}
 
void print_line(int _X)
{
  printf("-");
  for(int i = 0;i < _X;++i) printf("--");
  printf("\n");
}

void print_cover(double d)
{
  printf("cover: %f\n", d);
}

void print_hazard(double d)
{
  printf("hazard: %f\n", d);
}

void LOG(double x)
{
  std::cerr << "LOG: " << x << std::endl;
}

void print_state(int _X,int _Y,int id, int x, int y, int xf, int yf)
{
  if(round == 0) {
    xi = x; yi = y;
  }

  for(int i = 0;i < 150;++i) printf("\n");
  
  printf("round = %d : id = %d\n", ++round, id);
  printf("_X = %d _Y = %d\n",_X,_Y);
  print_line(_X);
  for(int i = 0;i < _Y;++i) {
    printf("|");
    for(int j = 0;j < _X;++j) {
      //printf("i = %d j = %d\n", i, j);
      if(j == xf && i == yf) printf("o|");        
      else if(j == x && i == y) printf("%d|",id);
      else printf(" |");
    }
    printf("\n");
    print_line(_X);
  }
}
%%}

//number of X and Y coordinates
CONST X = 20;
CONST Y = 20;

//states of each node
const INITS = 0;
const NEXT = 1;
const REQUEST = 2;
const WAITING = 3;
const MOVE = 4;

const TopY = 13;
const LeftX = -12.5;
const BottomY = -6;
const RightX = 6.5;

//-- radius of a node
CONST NODE_RAD = 0.25;

//-- assume that formation change takes 20 seconds
const FORM_CHANGE_TIME = 20.0;

//extern int MOVE_TO(unsigned char x,unsigned char y);
extern int my_sleep(int seconds);
extern void INIT_HAZARDS(int XX, int YY, int tx, int ty);
extern PURE double GET_HAZARD(int x, int y);
extern PURE void print_state(int XX,int YY,int id, int x, int y, int xf, int yf);
extern PURE void print_int(int i);
extern PURE void print_labeled_int(int i);
extern PURE void print_cover(double d);
extern PURE void print_hazard(double d);
extern PURE double wall_time();
extern PURE double GET_X();
extern PURE double GET_Y();
extern PURE double sqrt(double x);
extern PURE double asin(double x);
extern PURE void LOG(double x);

//-- the external function implementing the adaptation
//-- manager. returns 0 for loose formation and 1 for tight formation.
extern int adaptation_manager
(
 int current_formation, //-- 0 loose, 1 tight
 int changing, //-- whether in process of changing to other formation
 double change_progress, //-- progress in changing to other formation (remaining time)
 //-- next n hazards (for the next n segments in the path)
 double hazard1,
 double hazard2,
 double hazard3,
 double hazard4,
 double hazard5,
 //-- variance of the next n hazards predictions
 double variance1,
 double variance2,
 double variance3,
 double variance4,
 double variance5,
 double loose_speed, //-- speed of loose formation
 double tight_speed, //-- speed of tight formation
 double segment_length, //-- length of a segment in the path
 int remaining_segments, //-- number of segments remaining in the path
 double remaining_flight_time //-- how much flight time the formation has left
 );

//-- a random implementation of the adaptation manager. returns 0 for
//-- loose formation and 1 for tight formation. useful for testing.
extern int adaptation_manager_random
(
 int current_formation, //-- 0 loose, 1 tight
 int changing, //-- whether in process of changing to other formation
 double change_progress, //-- progress in changing to other formation (remaining time)
 //-- next n hazards (for the next n segments in the path)
 double hazard1,
 double hazard2,
 double hazard3,
 double hazard4,
 double hazard5,
 //-- variance of the next n hazards predictions
 double variance1,
 double variance2,
 double variance3,
 double variance4,
 double variance5,
 double loose_speed, //-- speed of loose formation
 double tight_speed, //-- speed of tight formation
 double segment_length, //-- length of a segment in the path
 int remaining_segments, //-- number of segments remaining in the path
 double remaining_flight_time //-- how much flight time the formation has left
 );

node uav (id)
{
  //shared variables -- visible across nodes. 
  //must be accessed via R() and W()
  global _Bool lock [X][Y];
  global unsigned char lx,ly; //leader's destination coordinates
  global _Bool init; //node is initialized

  //-- these variables are used to interact with the adaptation
  //-- manager
  global _Bool formation; //0 = loose, 1 = tight
  local _Bool changing; //are we changing formation now?
  local double remaining_time; //how much time left to complete formation change 
  //local double hazards[X][Y]; //map from cells to hazards
  local double current_hazard; //hazard of current x and y
  //local double variances[X][Y]; //map from cells to variances in hazard predictions
  //-- next 5 waypoints
  local unsigned char next_wp_x[5]; 
  local unsigned char next_wp_y[5]; 
  //-- next 5 hazards
  local double hazard1, hazard2, hazard3, hazard4, hazard5;
  //-- next 5 hazard variances
  local double variance1, variance2, variance3, variance4, variance5;
  //-- speeds in loose and tight formations
  local double loose_speed;
  local double tight_speed;
  //-- factor between speeds
  local double speed_factor;
  //-- segment length and remaining segments
  local double seg_len;
  local unsigned char remaining_segs;
  //-- remaining flight time
  local double remaining_flt_time;
  //-- total mission time, and mission start time
  local double total_time;
  local double start_time;

  //-- scenario selector
  local unsigned char scenario;
  
  //-- we use counters for the number of formation changes by each
  //-- node. when the leader initiates a formation change, it
  //-- increments its counter. it waits for the other counters to
  //-- catch up detect that the formation change has completed.
  global _Bool num_changes;
  
  //private variables -- local to the node.
  //preserved across rounds
  local unsigned char state; //the state
  local unsigned char x,y; //current coordinates
  local unsigned char xp,yp; //next coordinates
  local unsigned char xt,yt; //current target coordinates
  local _Bool waypointValid; //xt, yt are valid
  local double started_move;
  local double delay_until;

  //-- the function that computes the coverage of the
  //-- leader. currently we assume that protectors do not provide
  //-- overlapping coverage.
  PURE double coverage()
  {
    double cover, dist;
    double lat0,lng0,lat,lng;
    cover = 0.0;

    lat0 = GET_X()@id;
    lng0 = GET_Y()@id;

    if(lat0 == NAN || lng0 == NAN)
      return cover;

    FORALL_NODE(nid) {
      if(nid == id) continue;
      lat = GET_X()@nid;
      lng = GET_Y()@nid;

      dist = sqrt((lat - lat0) * (lat - lat0) +
                  (lng - lng0) * (lng - lng0));

      //-- to avoid the call to asin() from crashing. should never
      //-- happen.
      if(dist == 0.0 || dist == NAN) continue;
      
      cover = cover + asin(NODE_RAD/dist) / M_PI;
    }

    //print_cover(cover);
    //print_hazard(current_hazard);
    return cover;
    
    // Made up; depends on formation
    //return formation@0 ? 0.7 : 0.3;
  }

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_02(current_hazard * (1-coverage()) < 0.02);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_05(current_hazard * (1-coverage()) < 0.05);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_08(current_hazard * (1-coverage()) < 0.08);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_10(current_hazard * (1-coverage()) < 0.1);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_15(current_hazard * (1-coverage()) < 0.15);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_20(current_hazard * (1-coverage()) < 0.2);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_25(current_hazard * (1-coverage()) < 0.25);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_30(current_hazard * (1-coverage()) < 0.3);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_40(current_hazard * (1-coverage()) < 0.4);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_50(current_hazard * (1-coverage()) < 0.5);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_60(current_hazard * (1-coverage()) < 0.6);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_70(current_hazard * (1-coverage()) < 0.7);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_80(current_hazard * (1-coverage()) < 0.8);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_90(current_hazard * (1-coverage()) < 0.9);

  @AtLeast(0.25)
  @AtNode(0)
  expect COVERAGE_25_95(current_hazard * (1-coverage()) < 0.95);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_02(current_hazard * (1-coverage()) < 0.02);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_05(current_hazard * (1-coverage()) < 0.05);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_08(current_hazard * (1-coverage()) < 0.08);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_10(current_hazard * (1-coverage()) < 0.1);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_15(current_hazard * (1-coverage()) < 0.15);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_20(current_hazard * (1-coverage()) < 0.2);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_25(current_hazard * (1-coverage()) < 0.25);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_30(current_hazard * (1-coverage()) < 0.3);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_40(current_hazard * (1-coverage()) < 0.4);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_50(current_hazard * (1-coverage()) < 0.5);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_60(current_hazard * (1-coverage()) < 0.6);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_70(current_hazard * (1-coverage()) < 0.7);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_80(current_hazard * (1-coverage()) < 0.8);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_90(current_hazard * (1-coverage()) < 0.9);

  @AtLeast(0.5)
  @AtNode(0)
  expect COVERAGE_50_95(current_hazard * (1-coverage()) < 0.95);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_02(current_hazard * (1-coverage()) < 0.02);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_05(current_hazard * (1-coverage()) < 0.05);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_08(current_hazard * (1-coverage()) < 0.08);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_10(current_hazard * (1-coverage()) < 0.1);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_15(current_hazard * (1-coverage()) < 0.15);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_20(current_hazard * (1-coverage()) < 0.2);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_25(current_hazard * (1-coverage()) < 0.25);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_30(current_hazard * (1-coverage()) < 0.3);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_40(current_hazard * (1-coverage()) < 0.4);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_50(current_hazard * (1-coverage()) < 0.5);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_60(current_hazard * (1-coverage()) < 0.6);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_70(current_hazard * (1-coverage()) < 0.7);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_80(current_hazard * (1-coverage()) < 0.8);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_90(current_hazard * (1-coverage()) < 0.9);

  @AtLeast(0.62)
  @AtNode(0)
  expect COVERAGE_62_95(current_hazard * (1-coverage()) < 0.95);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_02(current_hazard * (1-coverage()) < 0.02);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_05(current_hazard * (1-coverage()) < 0.05);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_08(current_hazard * (1-coverage()) < 0.08);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_10(current_hazard * (1-coverage()) < 0.1);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_15(current_hazard * (1-coverage()) < 0.15);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_20(current_hazard * (1-coverage()) < 0.2);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_25(current_hazard * (1-coverage()) < 0.25);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_30(current_hazard * (1-coverage()) < 0.3);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_40(current_hazard * (1-coverage()) < 0.4);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_50(current_hazard * (1-coverage()) < 0.5);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_60(current_hazard * (1-coverage()) < 0.6);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_70(current_hazard * (1-coverage()) < 0.7);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_80(current_hazard * (1-coverage()) < 0.8);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_90(current_hazard * (1-coverage()) < 0.9);

  @AtLeast(0.75)
  @AtNode(0)
  expect COVERAGE_75_95(current_hazard * (1-coverage()) < 0.95);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_02(current_hazard * (1-coverage()) < 0.02);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_05(current_hazard * (1-coverage()) < 0.05);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_08(current_hazard * (1-coverage()) < 0.08);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_10(current_hazard * (1-coverage()) < 0.1);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_15(current_hazard * (1-coverage()) < 0.15);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_20(current_hazard * (1-coverage()) < 0.2);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_25(current_hazard * (1-coverage()) < 0.25);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_30(current_hazard * (1-coverage()) < 0.3);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_40(current_hazard * (1-coverage()) < 0.4);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_50(current_hazard * (1-coverage()) < 0.5);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_60(current_hazard * (1-coverage()) < 0.6);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_70(current_hazard * (1-coverage()) < 0.7);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_80(current_hazard * (1-coverage()) < 0.8);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_90(current_hazard * (1-coverage()) < 0.9);

  @AtLeast(0.82)
  @AtNode(0)
  expect COVERAGE_82_95(current_hazard * (1-coverage()) < 0.95);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_02(current_hazard * (1-coverage()) < 0.02);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_05(current_hazard * (1-coverage()) < 0.05);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_08(current_hazard * (1-coverage()) < 0.08);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_10(current_hazard * (1-coverage()) < 0.1);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_15(current_hazard * (1-coverage()) < 0.15);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_20(current_hazard * (1-coverage()) < 0.2);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_25(current_hazard * (1-coverage()) < 0.25);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_30(current_hazard * (1-coverage()) < 0.3);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_40(current_hazard * (1-coverage()) < 0.4);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_50(current_hazard * (1-coverage()) < 0.5);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_60(current_hazard * (1-coverage()) < 0.6);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_70(current_hazard * (1-coverage()) < 0.7);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_80(current_hazard * (1-coverage()) < 0.8);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_90(current_hazard * (1-coverage()) < 0.9);

  @AtLeast(0.90)
  @AtNode(0)
  expect COVERAGE_90_95(current_hazard * (1-coverage()) < 0.95);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_02(current_hazard * (1-coverage()) < 0.02);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_05(current_hazard * (1-coverage()) < 0.05);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_08(current_hazard * (1-coverage()) < 0.08);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_10(current_hazard * (1-coverage()) < 0.1);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_15(current_hazard * (1-coverage()) < 0.15);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_20(current_hazard * (1-coverage()) < 0.2);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_25(current_hazard * (1-coverage()) < 0.25);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_30(current_hazard * (1-coverage()) < 0.3);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_40(current_hazard * (1-coverage()) < 0.4);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_50(current_hazard * (1-coverage()) < 0.5);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_60(current_hazard * (1-coverage()) < 0.6);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_70(current_hazard * (1-coverage()) < 0.7);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_80(current_hazard * (1-coverage()) < 0.8);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_90(current_hazard * (1-coverage()) < 0.9);

  @AtLeast(0.95)
  @AtNode(0)
  expect COVERAGE_95_95(current_hazard * (1-coverage()) < 0.95);

  @AtEnd
  @AtNode(0)
  expect REACHED_END(x@0 == xt@0 && y@0 == yt@0);

  PURE double risk_integral()
  {
    if(id == 0)
      //return accumulate_risk(current_hazard * (1-coverage()) * 0.2);
      return INTEGRATE(current_hazard * (1-coverage()));
    else
      return 0.0;
  }

  //@AT_END
  //expect RISK_INTEGRAL(risk_integral() < 0.105);

  // True if you reach destination by end of mission time
  //@AT_END
  //expect REACHED_END(x@0 == xt@0 && y@0 == yt@0);
  
  // Completed and good coverage
  // 0.105 is -ln(0.9), 0.9 is desired success probability
  //@AtEnd
  //expect REACHED_END_AND_RISK_INTEGRAL(risk_integral() < 0.105 && x@0 == xt@0 && y@0 == yt@0);
  
  //-- return the next waypoint value
  _Bool NEXT_XY ()
  {
    if(!waypointValid)
      return 1;
    //-- set next coordinates
    xp = x; yp = y;
    if(xp < xt) xp = xp + 1;
    else if(xp > xt) xp = xp - 1;
    else if(yp < yt) yp = yp + 1;
    else if(yp > yt) yp = yp - 1;
    return 0;
  }

  //-- use this instead of NEXT_XY to enable diagonal movement. note
  //-- collision avoidance is not guaranteed under such movement.
  _Bool NEXT_XY_DIAGONAL ()
  {
    if(!waypointValid)
      return 1;
    xp = x; yp = y;
    if(x < xt) xp = x + 1;
    if(x > xt) xp = x - 1;
    if(y < yt) yp = y + 1;
    if(y > yt) yp = y - 1;
    return 0;
  }
  
  //-- only return the next waypoint X value given the current waypoint
  unsigned char NEXT_X (unsigned char curr_x, unsigned char curr_y)
  {
    if(curr_x < xt) return curr_x + 1;
    if(curr_x > xt) return curr_x - 1;
    return curr_x;
  }

  //-- only return the next waypoint Y value given the current waypoint
  unsigned char NEXT_Y (unsigned char curr_x, unsigned char curr_y)
  {
    if(curr_y < yt) return curr_y + 1;
    if(curr_y > yt) return curr_y - 1;
    return curr_y;
  }

  //-- manhattan distance between (x,y) and (xt,yt)
  unsigned char REMAINING_SEGMENTS()
  {
    unsigned char res;
    res = 0;
    if(x < xt) res = res + (xt - x);
    else if(x > xt) res = res + (x - xt);
    if(y < yt) res = res + (yt - y);
    else if(y > yt) res = res + (y - yt);
    return res;
  }

  //-- the task that invokes the adaptation manager. this task only
  //-- does something meaningful for the leader node (i.e., id =
  //-- 0). otherwise it is a NOP.
  thread ADAPTATION_MANAGER()
  {
    _Bool last_formation;    
    unsigned char num_protectors_changing;
    
    //-- not leader or uninitialized
    if(id != 0 || init@0 == 0) return;

    //-- check if formation change is still happening
    if(exists_lower(idp,num_changes@idp != num_changes@id) ||
       exists_higher(idp,num_changes@idp != num_changes@id)) {
      changing = 1;
    } else {
      changing = 0;
    }

    //-- estimate the remaining time for formation change as the
    //-- fraction of protectors that are yet to complete formation
    //-- change
    if(changing) {
      num_protectors_changing = 0;
      forall_other(idp) {
        if(num_changes@idp != num_changes@id) {
          num_protectors_changing = num_protectors_changing + 1;
        }
      }
      remaining_time = num_protectors_changing * FORM_CHANGE_TIME / 4;
    }
    
    //-- call the external adapatation manager
    last_formation = formation@0;

    //-- if the leader has reached the destination, no more formation
    //-- changes are needed
    if(x != xt || y != yt) {
      formation = adaptation_manager(formation@id,changing,remaining_time,
                                     hazard1, hazard2, hazard3, hazard4, hazard5,
                                     variance1, variance2, variance3, variance4, variance5,
                                     loose_speed, tight_speed,
                                     seg_len, remaining_segs,
                                     //total_time - (wall_time() - start_time),
                                     remaining_flt_time);
      print_labeled_int(formation@id);
    }
    
    //-- update the flag to indicate if a change formation is
    //-- triggered, and increment number of formation changes.
    if(!changing && last_formation != formation@0) {
      changing = 1;
      num_changes = 1 - num_changes@id;
    }
  }

  //-- the task that computes the next waypoint.
  thread WAYPOINT()
  {
    if(id != 0 && init@0 == 0) {
      waypointValid = 0;
      return;
    } else {
      waypointValid = 1;
    }

    //-- note that while a formation change is happening, there will
    //-- be no change in xp and yp for the leader.
    if(id == 0) {
      ly = yp;
      lx = xp;
      return;
    }

    //-- loose formation
    if(formation@0 == 0) {
      if(id == 1) {
        xt = lx@0 + 2;
        yt = ly@0 + 2;
      } else if(id == 2) {
        xt = lx@0 - 2;
        yt = ly@0 + 2;
      } else if(id == 3) {
        xt = lx@0 - 2;
        yt = ly@0 - 2;
      } else if(id == 4) {
        xt = lx@0 + 2;
        yt = ly@0 - 2;
      }
      return;
    }

    //-- tight formation
    if(id == 1) {
      xt = lx@0 + 1;
      yt = ly@0 + 1;
    } else if(id == 2) {
      xt = lx@0 - 1;
      yt = ly@0 + 1;
    } else if(id == 3) {
      xt = lx@0 - 1;
      yt = ly@0 - 1;
    } else if(id == 4) {
      xt = lx@0 + 1;
      yt = ly@0 - 1;
    }
  }

  //double GET_HAZARD(int curx, int cury)
  //{
    //if(id == 0 && curx == xt && cury == yt)
      //return 0.0;
    //else
      //return (curx > 4 && cury <= 4) ? 0.09 : 0.01;
  //}

  //-- set the next 5 hazards based on the next 5 waypoints. XXX: this
  //-- should be fixed once compiler support is added.
  void SET_HAZARDS()
  {
    if(id == 0)
    {
      hazard1 = GET_HAZARD(next_wp_x[0], next_wp_y[0]);
      hazard2 = GET_HAZARD(next_wp_x[1], next_wp_y[1]);
      hazard3 = GET_HAZARD(next_wp_x[2], next_wp_y[2]);
      hazard4 = GET_HAZARD(next_wp_x[3], next_wp_y[3]);
      hazard5 = GET_HAZARD(next_wp_x[4], next_wp_y[4]);
    }
    else
    {
      hazard1 = 0;
      hazard2 = 0;
      hazard3 = 0;
      hazard4 = 0;
      hazard5 = 0;
    }
  }

  //-- set the next 5 variances based on the next 5 waypoints. XXX:
  //-- this should be fixed once compiler support is added.
  void SET_VARIANCES()
  {
    variance1 = 0.1; variance2 = 0.1; variance3 = 0.1; variance4 = 0.1; variance5 = 0.1;
  }
  
  //-- initialize state
  void INITIALIZE_STATE()
  {
    unsigned char i,j;
    lock[x][y] = 1;
    lock[xp][yp] = 1;

    num_changes = 0;
    
    if(id != 0) return;

    //-- the rest of this stuff is only done by the leader
    lx = x;
    ly = y;
    current_hazard = GET_HAZARD(x,y);
    formation = 0;
    changing = 0;
    remaining_time = 0.0;

    delay_until = 0.0;
      
    //-- initialize hazards and variances arrays
    //for(i = 0;i < X;) {
    //i=0;
    //while(i < x) {
      //for(j = 0;j < Y;) {
      //j=0;
      //while(j < Y) {
        //-- we start with a simple hazard mapping
        //if(x > 4 && y <= 4) hazards[i][j] = 0.9;
        //else hazards[i][j] = 0.9;
        //-- variances are fixed and low
        //variances[i][j] = 0.01;
        //j = j+1;
      //}
      //i = i+1; //XXX: this should be part of the for loop header
    //}
    
    //-- also initialize next_wp_x and next_wp_y.
    next_wp_x[0] = x;
    next_wp_y[0] = y;

    //for(i = 1;i < 5;) {        
    i = 1;
    while(i < 5) {
      next_wp_x[i] = NEXT_X(next_wp_x[i - 1],next_wp_y[i - 1]);
      next_wp_y[i] = NEXT_Y(next_wp_y[i - 1],next_wp_y[i - 1]);
      i = i+1;
    }

    INIT_HAZARDS(X,Y,xt,yt);
    //initialize the next 5 hazards and variances
    SET_HAZARDS();
    SET_VARIANCES();
    
    //-- we set default values of some system parameters here. they
    //-- will likely be initialized from the command line.

    //-- NOTE: the difference between loose and tight speeds should
    //-- not be very small. otherwise, the prism model becomes too
    //-- hard to solve

    //-- NOTE: in the adaptation manager, the exposures for loose and
    //-- tight formations are set to 0.8 and 0.2. the ratio is 4.

    //-- select the scenario
    scenario = 2;
    
    //-----------------------------------------------------------------
    //-- begin scenarios
    //-----------------------------------------------------------------
    
    //-- SCENARIO 1: the ratio of loose and tight speeds is > 4. in
    //-- this case, there is no benefit to switch to tight formation.
    if(scenario == 1) {
      loose_speed = 50.0;
      tight_speed = 12.0;
      seg_len = 50.0;
      total_time = 15.0;
    }
    
    //-- SCENARIO 2: the ratio of loose and tight speeds is < 4. in
    //-- this case, there is benefit to switch to a tight formation.
    if(scenario == 2) {
      loose_speed = 50.0;
      tight_speed = 25.0;
      seg_len = 50.0;
      total_time = 15.0;
    }

    //-- SCENARIO 3: similar to scenario 2 but slightly longer mission
    //-- time so that the switch back to loose formation happens
    //-- later.
    if(scenario == 3) {
      loose_speed = 50.0;
      tight_speed = 25.0;
      seg_len = 50.0;
      total_time = 18.0;
    }

    speed_factor = loose_speed / tight_speed;

    //-----------------------------------------------------------------
    //-- begin scenarios
    //-----------------------------------------------------------------
    
    remaining_segs = REMAINING_SEGMENTS();
    remaining_flt_time = total_time;
    start_time = wall_time();
    
    init = 1;
  }

  //-- stuff to do once the next waypoint is reached
  void REACHED_NEXT_XY()
  {
    unsigned char i;

    lock[x][y] = 0; 
    x = xp; y = yp;
    current_hazard = GET_HAZARD(x,y);
    //-- if i am not the leader and a formation change was
    //-- happening, and i have reached the end-point, then formation
    //-- change is complete.
    if(id != 0 && num_changes@id != num_changes@0 && x == xt && y == yt) {
      num_changes = 1 - num_changes@id;
    }
    //For leader, update remaining segments, and next 5 waypoints
    if(id == 0) {
      //for(i = 1;i < 5;) {        
      i = 1;
      while(i < 5) {
        next_wp_x[i - 1] = next_wp_x[i];
        next_wp_y[i - 1] = next_wp_y[i];
        i = i+1;
      }
      next_wp_x[4] = NEXT_X(next_wp_x[3],next_wp_y[3]);
      next_wp_y[4] = NEXT_Y(next_wp_x[3],next_wp_y[3]);
      //-- update next 5 hazards and variances based on waypoints
      SET_HAZARDS();
      SET_VARIANCES();
      //-- reduced flight time
      remaining_flt_time = remaining_flt_time -
        (formation@id == 0 ? seg_len/loose_speed : seg_len/tight_speed);
      //-- one less segment to go
      remaining_segs = remaining_segs - 1;
    }
  }
  
  //-- the task that moves the node to its next waypoint while
  //-- avoiding collisions.
  @BarrierSync
  @PlatformController
  thread COLLISION_AVOIDANCE ()
  {
    print_state(X,Y,id,x,y,xt,yt);
    //my_sleep(1);
    if(state == INITS) {
      INITIALIZE_STATE();
      state = NEXT;
    }
    if(wall_time() < delay_until)
    {
      return;
    }
    if(state == NEXT) {
      //-- if reached destination, nothing to do
      if(x == xt && y == yt) return;
      //-- the leader does not move if formation change is going on
      if(id == 2 && changing) return;
      //-- get the next waypoint
      if(NEXT_XY()) return;
      state = REQUEST;
    } else if(state == REQUEST) {
      //request the lock but only if it is free
      if(exists_lower(idp,lock[xp][yp]@idp != 0)) return;
      lock[xp][yp] = 1;
      state = WAITING;
    } else if(state == WAITING) {
      //grab the lock if we are the highest 
      //id node to request or hold the lock
      if(exists_higher(idp, lock[xp][yp]@idp != 0)) return;
      state = MOVE;
    } else if(state == MOVE) {
      //now we have the lock on (x’,y’)
      if(started_move == 0)
      {
        started_move = wall_time();
      }
      if(GRID_MOVE(xp,yp,0.5)) return;
      REACHED_NEXT_XY();
      state = NEXT;
      if(id == 0 && started_move > 0 && formation@0 == 1 && speed_factor > 1)
      {
        delay_until = speed_factor * wall_time() - (speed_factor - 1) * started_move;
      }
      started_move = 0;
    }
  }

  @InitSim
  void StartingPosition ()
  {
    GRID_INIT(X, Y, LeftX, RightX, TopY, BottomY);
    GRID_PLACE(x, y, 0.5);
  }
}

//initial state
@INIT
void NodeInit () 
{
  forall_node(id) {
    state@id = INITS;
    ND(x@id); ND(y@id);
    ASSUME(0 <= x@id && x@id < X && 0 <= y@id && y@id < Y);
    ND(xt@id); ND(yt@id);
    ASSUME(0 <= xt@id && xt@id < X && 0 <= yt@id && yt@id < Y);
    waypointValid@id = 1;
    INIT_CONTROLLER(x@id,y@id)@id;
  }

  forall_distinct_node_pair (id1,id2) {
    ASSUME(x@id1 != x@id2 || y@id1 != y@id2);
  }
}

//the safety property checked at the beginning of each round
@SAFETY
void NoCollisions ()
{
  _Bool allIn,noneIn;

  FORALL_NODE(id) {
    /** state has to be between 0 and 4, (x,y), (xf,yf), and (xp,yp)
        have to be between 0 and X-1,Y-1 */
    ASSERT(state@id >= 0 && state@id <= 4);
    ASSERT(x@id >= 0 && x@id < X);
    ASSERT(y@id >= 0 && y@id < Y);
    ASSERT(xt@id >= 0 && xt@id < X);
    ASSERT(yt@id >= 0 && yt@id < Y);
    ASSERT(xp@id >= 0 && xp@id < X);
    ASSERT(yp@id >= 0 && yp@id < Y);
    /** if we are in not in INITS or NEXT, then xp,yp != x,y */
    ASSERT(state@id == INITS || state@id == NEXT || x@id != xp@id || y@id != yp@id);
    /** if we are in NEXT, REQUEST, WAITING or MOVE, we have lock on
        x,y */
    ASSERT((state@id != NEXT && state@id != REQUEST && state@id != WAITING && state@id != MOVE) ||
           lock[x@id][y@id]@id);
    /** if we are in NEXT, WAITING or MOVE, then we have lock on x,y
        and xp,yp */
    ASSERT((state@id != NEXT && state@id != WAITING && state@id != MOVE) ||
           (lock[x@id][y@id]@id && lock[xp@id][yp@id]@id));
    /** if we are not in INITS or NEXT, then x,y and xp,yp are
        adjacent */
    ASSERT(state@id == INITS || state@id == NEXT || (((x@id == xp@id - 1) || (x@id == xp@id + 1)) ^ ((y@id == yp@id - 1) || (y@id == yp@id + 1))));
    /** this is AC1 */
    /** controller always moves between adjacent cells*/
    ASSERT(cstate@id != CMOVE || (((cx@id == cxp@id - 1) || (cx@id == cxp@id + 1)) ^ ((cy@id == cyp@id - 1) || (cy@id == cyp@id + 1))));
    /** if controller is in MOVE, then node must also be in move, and
        if node and controller are both in MOVE, then their (x,y) and
        (xp,yp) agree */
    ASSERT((cstate@id != CMOVE || state@id == MOVE) &&                     
           (state@id != MOVE || cstate@id != CMOVE ||                    
            (x@id == cx@id && y@id == cy@id && xp@id == cxp@id && yp@id == cyp@id)));
    /** (x,y) of node and controller match */
    ASSERT(x@id == cx@id && y@id == cy@id);
  }
  
  FORALL_DISTINCT_NODE_PAIR (id1,id2) {
    /** this is AC2 */
    /** if node 1 and node 2 are in MOVE, then node1.(x,y) and
        node1.(xp,yp) are distinct from node.(x,y) and
        node2.(xp,yp) */
    ASSERT(cstate@id1 != CMOVE || cstate@id2 != CMOVE ||                  
           ((cx@id1 != cx@id2 || cy@id1 != cy@id2) &&               
            (cx@id1 != cxp@id2 || cy@id1 != cyp@id2) &&               
            (cxp@id1 != cx@id2 || cyp@id1 != cy@id2) &&               
            (cxp@id1 != cxp@id2 || cyp@id1 != cyp@id2)));

    /** this is AC3 */
    /** if node 1 is in HOVER and node 2 is in MOVE, then node1.(x,y)
        is distinct from node2.(x,y) and node2.(xp,yp) */
    ASSERT((cstate@id1 != CHOVER || cstate@id2 != CMOVE || 
                           ((cx@id1 != cx@id2 || cy@id1 != cy@id2) && 
                            (cx@id1 != cxp@id2 || cy@id1 != cyp@id2))) &&
           (cstate@id2 != CHOVER || cstate@id1 != CMOVE || 
                           ((cx@id2 != cx@id1 || cy@id2 != cy@id1) && 
                            (cx@id2 != cxp@id1 || cy@id2 != cyp@id1))));
    
    /** this is AC4 */
    /** if two distinct controllers are in HOVER, they have different
        (x,y) */
    ASSERT(cstate@id1 != CHOVER || cstate@id2 != CHOVER || cx@id1 != cx@id2 || cy@id1 != cy@id2);
  }

  //-- the rest are supporting invariants. you only need them for
  //-- plain induction. you can skip them (by uncommenting the
  //-- following return statement) out if you are doing K-induction
  //-- with K>=3.
  //return;
    
  /** either all nodes are in INITS or none is */
  allIn = 1; noneIn = 1;
  FORALL_NODE(id) {
    if(state@id == INITS) { noneIn = 0; }
    if(state@id != INITS) { allIn = 0; }
  }
  ASSERT(allIn || noneIn);
  
  FORALL_DISTINCT_NODE_PAIR (id1,id2) {
    /** if node1 is in MOVE/NEXT and has lower id than node2 which is
        WAITING then they have different xp,yp */
    ASSERT((state@id1 != NEXT && state@id1 != MOVE) || state@id2 != WAITING || id1 >= id2 || xp@id1 != xp@id2 || yp@id1 != yp@id2);
    /** if two distinct nodes are in MOVE, they have different
        (xp,yp) */
    ASSERT(state@id1 != MOVE || state@id2 != MOVE ||                        
           ((xp@id1 != xp@id2 || yp@id1 != yp@id2) &&             
            (xp@id1 != x@id2 || yp@id1 != y@id2) &&               
            (x@id1 != xp@id2 || y@id1 != yp@id2) &&               
            (x@id1 != x@id2 || y@id1 != y@id2)));
    /** if node2 in WAITING, and node1 has lower id than node 2, then
        node1.(x,y) != node2.(xp,yp) */
    ASSERT(state@id2 != WAITING || id1 >= id2 || x@id1 != xp@id2 || y@id1 != yp@id2);
    /** if node2 in MOVE, then node1.(x,y) != node2.(xp,yp) */
    ASSERT((state@id2 != MOVE || x@id1 != xp@id2 || y@id1 != yp@id2) && (state@id1 != 4 || xp@id1 != x@id2 || yp@id1 != y@id2));
    /** two distinct nodes have different (x,y) */
    ASSERT(x@id1 != x@id2 || y@id1 != y@id2);
  }
}

/*********************************************************************/
//-- end of file
/*********************************************************************/
