/*
 * generated by Xtext
 */
package edu.cmu.sei.annex.dmpl.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import edu.cmu.sei.annex.dmpl.dmpl.AdditiveExpr;
import edu.cmu.sei.annex.dmpl.dmpl.AndExpr;
import edu.cmu.sei.annex.dmpl.dmpl.AssignmentStmt;
import edu.cmu.sei.annex.dmpl.dmpl.AtEndSpec;
import edu.cmu.sei.annex.dmpl.dmpl.AtLeastSpec;
import edu.cmu.sei.annex.dmpl.dmpl.Attr;
import edu.cmu.sei.annex.dmpl.dmpl.Attributable;
import edu.cmu.sei.annex.dmpl.dmpl.AttributableNoRole;
import edu.cmu.sei.annex.dmpl.dmpl.AttributableProgramElement;
import edu.cmu.sei.annex.dmpl.dmpl.BitwiseAndExpr;
import edu.cmu.sei.annex.dmpl.dmpl.BitwiseOrExpr;
import edu.cmu.sei.annex.dmpl.dmpl.BuiltInExpr;
import edu.cmu.sei.annex.dmpl.dmpl.CallExpr;
import edu.cmu.sei.annex.dmpl.dmpl.CompareExpr;
import edu.cmu.sei.annex.dmpl.dmpl.CondStmt;
import edu.cmu.sei.annex.dmpl.dmpl.Constant;
import edu.cmu.sei.annex.dmpl.dmpl.Defineline;
import edu.cmu.sei.annex.dmpl.dmpl.DmplPackage;
import edu.cmu.sei.annex.dmpl.dmpl.DmplSubclause;
import edu.cmu.sei.annex.dmpl.dmpl.DoubleConst;
import edu.cmu.sei.annex.dmpl.dmpl.DoubleExpr;
import edu.cmu.sei.annex.dmpl.dmpl.EqualityExpr;
import edu.cmu.sei.annex.dmpl.dmpl.ExprVarAsgn;
import edu.cmu.sei.annex.dmpl.dmpl.FadnpStmt;
import edu.cmu.sei.annex.dmpl.dmpl.FnBody;
import edu.cmu.sei.annex.dmpl.dmpl.FnVarAsgn;
import edu.cmu.sei.annex.dmpl.dmpl.ForAllStmt;
import edu.cmu.sei.annex.dmpl.dmpl.ForStmt;
import edu.cmu.sei.annex.dmpl.dmpl.FunctionDeclaration;
import edu.cmu.sei.annex.dmpl.dmpl.IdDimension;
import edu.cmu.sei.annex.dmpl.dmpl.IdExpr;
import edu.cmu.sei.annex.dmpl.dmpl.IdRole;
import edu.cmu.sei.annex.dmpl.dmpl.Includeline;
import edu.cmu.sei.annex.dmpl.dmpl.IncrementStmt;
import edu.cmu.sei.annex.dmpl.dmpl.InitAssignmentStmt;
import edu.cmu.sei.annex.dmpl.dmpl.IntConst;
import edu.cmu.sei.annex.dmpl.dmpl.IntDimension;
import edu.cmu.sei.annex.dmpl.dmpl.IntExpr;
import edu.cmu.sei.annex.dmpl.dmpl.LVal;
import edu.cmu.sei.annex.dmpl.dmpl.MultiplicativeExpr;
import edu.cmu.sei.annex.dmpl.dmpl.NestedStmt;
import edu.cmu.sei.annex.dmpl.dmpl.Node;
import edu.cmu.sei.annex.dmpl.dmpl.NodeNumDimension;
import edu.cmu.sei.annex.dmpl.dmpl.NodeNumExpr;
import edu.cmu.sei.annex.dmpl.dmpl.NodeVarInit;
import edu.cmu.sei.annex.dmpl.dmpl.OrExpr;
import edu.cmu.sei.annex.dmpl.dmpl.Param;
import edu.cmu.sei.annex.dmpl.dmpl.ParenthesizedExpr;
import edu.cmu.sei.annex.dmpl.dmpl.Program;
import edu.cmu.sei.annex.dmpl.dmpl.RecordBlock;
import edu.cmu.sei.annex.dmpl.dmpl.RequireSpec;
import edu.cmu.sei.annex.dmpl.dmpl.ReturnValueStmt;
import edu.cmu.sei.annex.dmpl.dmpl.ShiftExpr;
import edu.cmu.sei.annex.dmpl.dmpl.SimpleRole;
import edu.cmu.sei.annex.dmpl.dmpl.SimpleStmt;
import edu.cmu.sei.annex.dmpl.dmpl.StringExpr;
import edu.cmu.sei.annex.dmpl.dmpl.Target;
import edu.cmu.sei.annex.dmpl.dmpl.TernaryExpr;
import edu.cmu.sei.annex.dmpl.dmpl.ThreadDeclaration;
import edu.cmu.sei.annex.dmpl.dmpl.Type;
import edu.cmu.sei.annex.dmpl.dmpl.UnaryExpr;
import edu.cmu.sei.annex.dmpl.dmpl.Var;
import edu.cmu.sei.annex.dmpl.dmpl.VarAsgn;
import edu.cmu.sei.annex.dmpl.dmpl.VarBlock;
import edu.cmu.sei.annex.dmpl.dmpl.VarInit;
import edu.cmu.sei.annex.dmpl.dmpl.WhileStmt;
import edu.cmu.sei.annex.dmpl.dmpl.XorExpr;
import edu.cmu.sei.annex.dmpl.services.DmplGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DmplSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DmplGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == DmplPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case DmplPackage.ADDITIVE_EXPR:
				sequence_AdditiveExpr(context, (AdditiveExpr) semanticObject); 
				return; 
			case DmplPackage.AND_EXPR:
				sequence_AndExpr(context, (AndExpr) semanticObject); 
				return; 
			case DmplPackage.ASSIGNMENT_STMT:
				sequence_AssignmentStmt(context, (AssignmentStmt) semanticObject); 
				return; 
			case DmplPackage.AT_END_SPEC:
				sequence_Specification(context, (AtEndSpec) semanticObject); 
				return; 
			case DmplPackage.AT_LEAST_SPEC:
				sequence_Specification(context, (AtLeastSpec) semanticObject); 
				return; 
			case DmplPackage.ATTR:
				sequence_Attr(context, (Attr) semanticObject); 
				return; 
			case DmplPackage.ATTRIBUTABLE:
				sequence_NodeBodyElement(context, (Attributable) semanticObject); 
				return; 
			case DmplPackage.ATTRIBUTABLE_NO_ROLE:
				sequence_RoleBodyElement(context, (AttributableNoRole) semanticObject); 
				return; 
			case DmplPackage.ATTRIBUTABLE_PROGRAM_ELEMENT:
				sequence_ProgramElementNoTarget(context, (AttributableProgramElement) semanticObject); 
				return; 
			case DmplPackage.BITWISE_AND_EXPR:
				sequence_BitwiseAndExpr(context, (BitwiseAndExpr) semanticObject); 
				return; 
			case DmplPackage.BITWISE_OR_EXPR:
				sequence_BitwiseOrExpr(context, (BitwiseOrExpr) semanticObject); 
				return; 
			case DmplPackage.BUILT_IN_EXPR:
				sequence_TerminalExpr(context, (BuiltInExpr) semanticObject); 
				return; 
			case DmplPackage.CALL_EXPR:
				sequence_CallExpr(context, (CallExpr) semanticObject); 
				return; 
			case DmplPackage.COMPARE_EXPR:
				sequence_CompareExpr(context, (CompareExpr) semanticObject); 
				return; 
			case DmplPackage.COND_STMT:
				sequence_Stmt(context, (CondStmt) semanticObject); 
				return; 
			case DmplPackage.CONSTANT:
				sequence_ProgramElementNoTarget(context, (Constant) semanticObject); 
				return; 
			case DmplPackage.DEFINELINE:
				sequence_ProgramElementNoTarget(context, (Defineline) semanticObject); 
				return; 
			case DmplPackage.DMPL_SUBCLAUSE:
				sequence_DmplSubclause(context, (DmplSubclause) semanticObject); 
				return; 
			case DmplPackage.DOUBLE_CONST:
				sequence_DoubleConst(context, (DoubleConst) semanticObject); 
				return; 
			case DmplPackage.DOUBLE_EXPR:
				sequence_TerminalExpr(context, (DoubleExpr) semanticObject); 
				return; 
			case DmplPackage.EQUALITY_EXPR:
				sequence_EqualityExpr(context, (EqualityExpr) semanticObject); 
				return; 
			case DmplPackage.EXPR_VAR_ASGN:
				sequence_VarAsgn(context, (ExprVarAsgn) semanticObject); 
				return; 
			case DmplPackage.FADNP_STMT:
				sequence_Stmt(context, (FadnpStmt) semanticObject); 
				return; 
			case DmplPackage.FN_BODY:
				sequence_FnBody(context, (FnBody) semanticObject); 
				return; 
			case DmplPackage.FN_VAR_ASGN:
				sequence_VarAsgn(context, (FnVarAsgn) semanticObject); 
				return; 
			case DmplPackage.FOR_ALL_STMT:
				sequence_Stmt(context, (ForAllStmt) semanticObject); 
				return; 
			case DmplPackage.FOR_STMT:
				sequence_Stmt(context, (ForStmt) semanticObject); 
				return; 
			case DmplPackage.FUNCTION_DECLARATION:
				sequence_Procedure(context, (FunctionDeclaration) semanticObject); 
				return; 
			case DmplPackage.ID_DIMENSION:
				sequence_Dimension(context, (IdDimension) semanticObject); 
				return; 
			case DmplPackage.ID_EXPR:
				sequence_TerminalExpr(context, (IdExpr) semanticObject); 
				return; 
			case DmplPackage.ID_ROLE:
				sequence_AttributableElement(context, (IdRole) semanticObject); 
				return; 
			case DmplPackage.INCLUDELINE:
				sequence_ProgramElementNoTarget(context, (Includeline) semanticObject); 
				return; 
			case DmplPackage.INCREMENT_STMT:
				sequence_IncrementStmt(context, (IncrementStmt) semanticObject); 
				return; 
			case DmplPackage.INIT_ASSIGNMENT_STMT:
				sequence_InitAssignmentStmt(context, (InitAssignmentStmt) semanticObject); 
				return; 
			case DmplPackage.INT_CONST:
				sequence_NumberConst(context, (IntConst) semanticObject); 
				return; 
			case DmplPackage.INT_DIMENSION:
				sequence_Dimension(context, (IntDimension) semanticObject); 
				return; 
			case DmplPackage.INT_EXPR:
				sequence_TerminalExpr(context, (IntExpr) semanticObject); 
				return; 
			case DmplPackage.LVAL:
				sequence_LVal(context, (LVal) semanticObject); 
				return; 
			case DmplPackage.MULTIPLICATIVE_EXPR:
				sequence_MultiplicativeExpr(context, (MultiplicativeExpr) semanticObject); 
				return; 
			case DmplPackage.NESTED_STMT:
				sequence_Stmt(context, (NestedStmt) semanticObject); 
				return; 
			case DmplPackage.NODE:
				sequence_AttributableNodeOrProcedure(context, (Node) semanticObject); 
				return; 
			case DmplPackage.NODE_NUM_DIMENSION:
				sequence_Dimension(context, (NodeNumDimension) semanticObject); 
				return; 
			case DmplPackage.NODE_NUM_EXPR:
				sequence_TerminalExpr(context, (NodeNumExpr) semanticObject); 
				return; 
			case DmplPackage.NODE_VAR_INIT:
				sequence_NodeVarInit(context, (NodeVarInit) semanticObject); 
				return; 
			case DmplPackage.OR_EXPR:
				sequence_OrExpr(context, (OrExpr) semanticObject); 
				return; 
			case DmplPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case DmplPackage.PARENTHESIZED_EXPR:
				sequence_TerminalExpr(context, (ParenthesizedExpr) semanticObject); 
				return; 
			case DmplPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case DmplPackage.RECORD_BLOCK:
				sequence_RecordBlock(context, (RecordBlock) semanticObject); 
				return; 
			case DmplPackage.REQUIRE_SPEC:
				sequence_Specification(context, (RequireSpec) semanticObject); 
				return; 
			case DmplPackage.RETURN_VALUE_STMT:
				sequence_Stmt(context, (ReturnValueStmt) semanticObject); 
				return; 
			case DmplPackage.SHIFT_EXPR:
				sequence_ShiftExpr(context, (ShiftExpr) semanticObject); 
				return; 
			case DmplPackage.SIMPLE_ROLE:
				sequence_AttributableElement(context, (SimpleRole) semanticObject); 
				return; 
			case DmplPackage.SIMPLE_STMT:
				sequence_Stmt(context, (SimpleStmt) semanticObject); 
				return; 
			case DmplPackage.STRING_EXPR:
				sequence_TerminalExpr(context, (StringExpr) semanticObject); 
				return; 
			case DmplPackage.TARGET:
				sequence_ProgramElement(context, (Target) semanticObject); 
				return; 
			case DmplPackage.TERNARY_EXPR:
				sequence_Expr(context, (TernaryExpr) semanticObject); 
				return; 
			case DmplPackage.THREAD_DECLARATION:
				sequence_Procedure(context, (ThreadDeclaration) semanticObject); 
				return; 
			case DmplPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case DmplPackage.UNARY_EXPR:
				sequence_TerminalExpr(context, (UnaryExpr) semanticObject); 
				return; 
			case DmplPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case DmplPackage.VAR_ASGN:
				sequence_VarAsgn(context, (VarAsgn) semanticObject); 
				return; 
			case DmplPackage.VAR_BLOCK:
				sequence_VarBlock(context, (VarBlock) semanticObject); 
				return; 
			case DmplPackage.VAR_INIT:
				sequence_VarInit(context, (VarInit) semanticObject); 
				return; 
			case DmplPackage.WHILE_STMT:
				sequence_Stmt(context, (WhileStmt) semanticObject); 
				return; 
			case DmplPackage.XOR_EXPR:
				sequence_XorExpr(context, (XorExpr) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (left=AdditiveExpr_AdditiveExpr_1_0_0_0 operator=AdditiveOperator right=MultiplicativeExpr)
	 */
	protected void sequence_AdditiveExpr(EObject context, AdditiveExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.ADDITIVE_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.ADDITIVE_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.ADDITIVE_EXPR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.ADDITIVE_EXPR__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.ADDITIVE_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.ADDITIVE_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAdditiveExprAccess().getAdditiveExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditiveExprAccess().getOperatorAdditiveOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAdditiveExprAccess().getRightMultiplicativeExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=AndExpr_AndExpr_1_0_0_0 right=BitwiseOrExpr)
	 */
	protected void sequence_AndExpr(EObject context, AndExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.AND_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.AND_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.AND_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.AND_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAndExprAccess().getAndExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExprAccess().getRightBitwiseOrExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (variable=LVal value=Expr)
	 */
	protected void sequence_AssignmentStmt(EObject context, AssignmentStmt semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.ASSIGNMENT_STMT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.ASSIGNMENT_STMT__VARIABLE));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.ASSIGNMENT_STMT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.ASSIGNMENT_STMT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignmentStmtAccess().getVariableLValParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAssignmentStmtAccess().getValueExprParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER (params+=Expr params+=Expr*)?)
	 */
	protected void sequence_Attr(EObject context, Attr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER id=INT elements+=RoleBodyElement*)
	 */
	protected void sequence_AttributableElement(EObject context, IdRole semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER elements+=RoleBodyElement*)
	 */
	protected void sequence_AttributableElement(EObject context, SimpleRole semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER elements+=NodeBodyElement*)
	 */
	protected void sequence_AttributableNodeOrProcedure(EObject context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=BitwiseAndExpr_BitwiseAndExpr_1_0_0_0 right=EqualityExpr)
	 */
	protected void sequence_BitwiseAndExpr(EObject context, BitwiseAndExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.BITWISE_AND_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.BITWISE_AND_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.BITWISE_AND_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.BITWISE_AND_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBitwiseAndExprAccess().getBitwiseAndExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitwiseAndExprAccess().getRightEqualityExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=BitwiseOrExpr_BitwiseOrExpr_1_0_0_0 right=XorExpr)
	 */
	protected void sequence_BitwiseOrExpr(EObject context, BitwiseOrExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.BITWISE_OR_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.BITWISE_OR_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.BITWISE_OR_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.BITWISE_OR_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBitwiseOrExprAccess().getBitwiseOrExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitwiseOrExprAccess().getRightXorExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (namespaces+=TIDENTIFIER* name=TIDENTIFIER (args+=Expr args+=Expr*)? at=Expr?)
	 */
	protected void sequence_CallExpr(EObject context, CallExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=CompareExpr_CompareExpr_1_0_0_0 operator=CompareOperator right=ShiftExpr)
	 */
	protected void sequence_CompareExpr(EObject context, CompareExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.COMPARE_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.COMPARE_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.COMPARE_EXPR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.COMPARE_EXPR__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.COMPARE_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.COMPARE_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCompareExprAccess().getCompareExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareExprAccess().getOperatorCompareOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getCompareExprAccess().getRightShiftExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     index=TIDENTIFIER
	 */
	protected void sequence_Dimension(EObject context, IdDimension semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.ID_DIMENSION__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.ID_DIMENSION__INDEX));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDimensionAccess().getIndexTIDENTIFIERTerminalRuleCall_2_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     index=INT
	 */
	protected void sequence_Dimension(EObject context, IntDimension semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.INT_DIMENSION__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.INT_DIMENSION__INDEX));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDimensionAccess().getIndexINTTerminalRuleCall_0_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {NodeNumDimension}
	 */
	protected void sequence_Dimension(EObject context, NodeNumDimension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     program=Program
	 */
	protected void sequence_DmplSubclause(EObject context, DmplSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sign=Sign? value=Double)
	 */
	protected void sequence_DoubleConst(EObject context, DoubleConst semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=EqualityExpr_EqualityExpr_1_0_0_0 operator=EqualityOperator right=CompareExpr)
	 */
	protected void sequence_EqualityExpr(EObject context, EqualityExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.EQUALITY_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.EQUALITY_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.EQUALITY_EXPR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.EQUALITY_EXPR__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.EQUALITY_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.EQUALITY_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEqualityExprAccess().getEqualityExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityExprAccess().getOperatorEqualityOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getEqualityExprAccess().getRightCompareExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Expr_TernaryExpr_1_0_0_0 then=Expr else=Expr)
	 */
	protected void sequence_Expr(EObject context, TernaryExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.TERNARY_EXPR__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.TERNARY_EXPR__CONDITION));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.TERNARY_EXPR__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.TERNARY_EXPR__THEN));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.TERNARY_EXPR__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.TERNARY_EXPR__ELSE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExprAccess().getTernaryExprConditionAction_1_0_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getExprAccess().getThenExprParserRuleCall_1_1_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getExprAccess().getElseExprParserRuleCall_1_3_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (varInits+=VarInit* stmts+=Stmt*)
	 */
	protected void sequence_FnBody(EObject context, FnBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (var=TIDENTIFIER | var=TIDENTIFIER)
	 */
	protected void sequence_IncrementStmt(EObject context, IncrementStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type? variable=LVal value=Expr)
	 */
	protected void sequence_InitAssignmentStmt(EObject context, InitAssignmentStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER indices+=Expr* at=Expr?)
	 */
	protected void sequence_LVal(EObject context, LVal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=MultiplicativeExpr_MultiplicativeExpr_1_0_0_0 operator=MultiplicativeOperator right=TerminalExpr)
	 */
	protected void sequence_MultiplicativeExpr(EObject context, MultiplicativeExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getMultiplicativeExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getOperatorMultiplicativeOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getRightTerminalExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (attrs+=Attr* element=AttributableElement)
	 */
	protected void sequence_NodeBodyElement(EObject context, Attributable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (scope=NodeVarScope var=VarInit)
	 */
	protected void sequence_NodeVarInit(EObject context, NodeVarInit semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.NODE_VAR_INIT__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.NODE_VAR_INIT__SCOPE));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.NODE_VAR_INIT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.NODE_VAR_INIT__VAR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNodeVarInitAccess().getScopeNodeVarScopeParserRuleCall_0_0(), semanticObject.getScope());
		feeder.accept(grammarAccess.getNodeVarInitAccess().getVarVarInitParserRuleCall_1_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (sign=Sign? value=INT)
	 */
	protected void sequence_NumberConst(EObject context, IntConst semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=OrExpr_OrExpr_1_0_0_0 right=AndExpr)
	 */
	protected void sequence_OrExpr(EObject context, OrExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.OR_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.OR_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.OR_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.OR_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOrExprAccess().getOrExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExprAccess().getRightAndExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type var=Var)
	 */
	protected void sequence_Param(EObject context, Param semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.PARAM__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.PARAM__TYPE));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.PARAM__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.PARAM__VAR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParamAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParamAccess().getVarVarParserRuleCall_1_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         override?='override'? 
	 *         (extern?='extern' | extern?='EXTERN')? 
	 *         (pure?='pure' | pure?='PURE')? 
	 *         type=Type 
	 *         name=TIDENTIFIER 
	 *         (params+=Param params+=Param*)? 
	 *         fnBody=FnBody?
	 *     )
	 */
	protected void sequence_Procedure(EObject context, FunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (override?='override'? (extern?='extern' | extern?='EXTERN')? (pure?='pure' | pure?='PURE')? name=TIDENTIFIER fnBody=FnBody?)
	 */
	protected void sequence_Procedure(EObject context, ThreadDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (attrs+=Attr* element=AttributableNodeOrProcedure)
	 */
	protected void sequence_ProgramElementNoTarget(EObject context, AttributableProgramElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER value=NumberConst)
	 */
	protected void sequence_ProgramElementNoTarget(EObject context, Constant semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.CONSTANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.CONSTANT__NAME));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.CONSTANT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProgramElementNoTargetAccess().getNameTIDENTIFIERTerminalRuleCall_2_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getProgramElementNoTargetAccess().getValueNumberConstParserRuleCall_2_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     line=DEFINE_LINE
	 */
	protected void sequence_ProgramElementNoTarget(EObject context, Defineline semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.DEFINELINE__LINE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.DEFINELINE__LINE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProgramElementNoTargetAccess().getLineDEFINE_LINETerminalRuleCall_1_1_0(), semanticObject.getLine());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     line=INCLUDE_LINE
	 */
	protected void sequence_ProgramElementNoTarget(EObject context, Includeline semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.INCLUDELINE__LINE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.INCLUDELINE__LINE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProgramElementNoTargetAccess().getLineINCLUDE_LINETerminalRuleCall_0_1_0(), semanticObject.getLine());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (names+=TIDENTIFIER names+=TIDENTIFIER* thunk=THUNKTEXT)
	 */
	protected void sequence_ProgramElement(EObject context, Target semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=ProgramElement*)
	 */
	protected void sequence_Program(EObject context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (override?='override'? name=TIDENTIFIER vars+=NodeVarInit+ equalsBody=FnBody? complementBody=FnBody?)
	 */
	protected void sequence_RecordBlock(EObject context, RecordBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (attrs+=Attr* element=AttributableNoRoleElement)
	 */
	protected void sequence_RoleBodyElement(EObject context, AttributableNoRole semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=ShiftExpr_ShiftExpr_1_0_0_0 operator=ShiftOperator right=AdditiveExpr)
	 */
	protected void sequence_ShiftExpr(EObject context, ShiftExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.SHIFT_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.SHIFT_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.SHIFT_EXPR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.SHIFT_EXPR__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.SHIFT_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.SHIFT_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getShiftExprAccess().getShiftExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getShiftExprAccess().getOperatorShiftOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getShiftExprAccess().getRightAdditiveExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER function=TIDENTIFIER)
	 */
	protected void sequence_Specification(EObject context, AtEndSpec semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.SPECIFICATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.SPECIFICATION__NAME));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.SPECIFICATION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.SPECIFICATION__FUNCTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSpecificationAccess().getNameTIDENTIFIERTerminalRuleCall_0_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSpecificationAccess().getFunctionTIDENTIFIERTerminalRuleCall_0_6_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER threshold=DoubleConst function=TIDENTIFIER)
	 */
	protected void sequence_Specification(EObject context, AtLeastSpec semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.SPECIFICATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.SPECIFICATION__NAME));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.SPECIFICATION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.SPECIFICATION__FUNCTION));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.AT_LEAST_SPEC__THRESHOLD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.AT_LEAST_SPEC__THRESHOLD));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSpecificationAccess().getNameTIDENTIFIERTerminalRuleCall_1_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSpecificationAccess().getThresholdDoubleConstParserRuleCall_1_5_0(), semanticObject.getThreshold());
		feeder.accept(grammarAccess.getSpecificationAccess().getFunctionTIDENTIFIERTerminalRuleCall_1_7_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER function=TIDENTIFIER)
	 */
	protected void sequence_Specification(EObject context, RequireSpec semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.SPECIFICATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.SPECIFICATION__NAME));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.SPECIFICATION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.SPECIFICATION__FUNCTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSpecificationAccess().getNameTIDENTIFIERTerminalRuleCall_2_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSpecificationAccess().getFunctionTIDENTIFIERTerminalRuleCall_2_4_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (attrs+=Attr* condition=Expr then=Stmt else=Stmt?)
	 */
	protected void sequence_Stmt(EObject context, CondStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (node1=TIDENTIFIER node2=TIDENTIFIER stmt=Stmt)
	 */
	protected void sequence_Stmt(EObject context, FadnpStmt semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.FADNP_STMT__NODE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.FADNP_STMT__NODE1));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.FADNP_STMT__NODE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.FADNP_STMT__NODE2));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.FADNP_STMT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.FADNP_STMT__STMT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStmtAccess().getNode1TIDENTIFIERTerminalRuleCall_9_3_0(), semanticObject.getNode1());
		feeder.accept(grammarAccess.getStmtAccess().getNode2TIDENTIFIERTerminalRuleCall_9_5_0(), semanticObject.getNode2());
		feeder.accept(grammarAccess.getStmtAccess().getStmtStmtParserRuleCall_9_7_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ForAllFunction node=TIDENTIFIER stmt=Stmt)
	 */
	protected void sequence_Stmt(EObject context, ForAllStmt semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.FOR_ALL_STMT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.FOR_ALL_STMT__NAME));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.FOR_ALL_STMT__NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.FOR_ALL_STMT__NODE));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.FOR_ALL_STMT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.FOR_ALL_STMT__STMT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStmtAccess().getNameForAllFunctionParserRuleCall_8_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStmtAccess().getNodeTIDENTIFIERTerminalRuleCall_8_3_0(), semanticObject.getNode());
		feeder.accept(grammarAccess.getStmtAccess().getStmtStmtParserRuleCall_8_5_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((inits+=InitAssignmentStmt inits+=InitAssignmentStmt*)? condition=Expr? update=AssignmentOrIncrementStmt? stmt=Stmt)
	 */
	protected void sequence_Stmt(EObject context, ForStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (stmts+=Stmt*)
	 */
	protected void sequence_Stmt(EObject context, NestedStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=Expr
	 */
	protected void sequence_Stmt(EObject context, ReturnValueStmt semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.RETURN_VALUE_STMT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.RETURN_VALUE_STMT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStmtAccess().getValueExprParserRuleCall_6_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=SimpleStmtKeyword
	 */
	protected void sequence_Stmt(EObject context, SimpleStmt semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.SIMPLE_STMT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.SIMPLE_STMT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStmtAccess().getNameSimpleStmtKeywordParserRuleCall_5_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Expr stmt=Stmt)
	 */
	protected void sequence_Stmt(EObject context, WhileStmt semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.WHILE_STMT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.WHILE_STMT__CONDITION));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.WHILE_STMT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.WHILE_STMT__STMT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStmtAccess().getConditionExprParserRuleCall_2_3_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getStmtAccess().getStmtStmtParserRuleCall_2_5_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (function=BuiltInFunction firstArg=TIDENTIFIER secondArg=Expr)
	 */
	protected void sequence_TerminalExpr(EObject context, BuiltInExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__FUNCTION));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__FIRST_ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__FIRST_ARG));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__SECOND_ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__SECOND_ARG));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalExprAccess().getFunctionBuiltInFunctionParserRuleCall_7_1_0(), semanticObject.getFunction());
		feeder.accept(grammarAccess.getTerminalExprAccess().getFirstArgTIDENTIFIERTerminalRuleCall_7_3_0(), semanticObject.getFirstArg());
		feeder.accept(grammarAccess.getTerminalExprAccess().getSecondArgExprParserRuleCall_7_5_0(), semanticObject.getSecondArg());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=Double
	 */
	protected void sequence_TerminalExpr(EObject context, DoubleExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.DOUBLE_EXPR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.DOUBLE_EXPR__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalExprAccess().getValueDoubleParserRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {IdExpr}
	 */
	protected void sequence_TerminalExpr(EObject context, IdExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_TerminalExpr(EObject context, IntExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.INT_EXPR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.INT_EXPR__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalExprAccess().getValueINTTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {NodeNumExpr}
	 */
	protected void sequence_TerminalExpr(EObject context, NodeNumExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=Expr
	 */
	protected void sequence_TerminalExpr(EObject context, ParenthesizedExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.PARENTHESIZED_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.PARENTHESIZED_EXPR__EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalExprAccess().getExprExprParserRuleCall_9_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_TerminalExpr(EObject context, StringExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.STRING_EXPR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.STRING_EXPR__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalExprAccess().getValueSTRINGTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operator=UnaryOperator operand=Expr)
	 */
	protected void sequence_TerminalExpr(EObject context, UnaryExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.UNARY_EXPR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.UNARY_EXPR__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.UNARY_EXPR__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.UNARY_EXPR__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalExprAccess().getOperatorUnaryOperatorEnumRuleCall_6_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getTerminalExprAccess().getOperandExprParserRuleCall_6_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (signed=Signed? simpType=SimpType)
	 */
	protected void sequence_Type(EObject context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((var=Var | (input?='input' var=Var)) expr=Expr)
	 */
	protected void sequence_VarAsgn(EObject context, ExprVarAsgn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((var=Var | (input?='input' var=Var)) fnBody=FnBody)
	 */
	protected void sequence_VarAsgn(EObject context, FnVarAsgn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (input?='input'? var=Var)
	 */
	protected void sequence_VarAsgn(EObject context, VarAsgn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (override?='override'? var=NodeVarInit)
	 */
	protected void sequence_VarBlock(EObject context, VarBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type varAsgns+=VarAsgn varAsgns+=VarAsgn*)
	 */
	protected void sequence_VarInit(EObject context, VarInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER dimensions+=Dimension*)
	 */
	protected void sequence_Var(EObject context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=XorExpr_XorExpr_1_0_0_0 right=BitwiseAndExpr)
	 */
	protected void sequence_XorExpr(EObject context, XorExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.XOR_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.XOR_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.XOR_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.XOR_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXorExprAccess().getXorExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXorExprAccess().getRightBitwiseAndExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
}
