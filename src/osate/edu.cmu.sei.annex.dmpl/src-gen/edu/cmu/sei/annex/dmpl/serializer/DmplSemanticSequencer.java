/*
 * generated by Xtext
 */
package edu.cmu.sei.annex.dmpl.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import edu.cmu.sei.annex.dmpl.dmpl.ArgList;
import edu.cmu.sei.annex.dmpl.dmpl.BuiltInExpr;
import edu.cmu.sei.annex.dmpl.dmpl.CallExpr;
import edu.cmu.sei.annex.dmpl.dmpl.Constant;
import edu.cmu.sei.annex.dmpl.dmpl.DmplPackage;
import edu.cmu.sei.annex.dmpl.dmpl.DmplSubclause;
import edu.cmu.sei.annex.dmpl.dmpl.DoubleConst;
import edu.cmu.sei.annex.dmpl.dmpl.DoubleExpr;
import edu.cmu.sei.annex.dmpl.dmpl.FnBody;
import edu.cmu.sei.annex.dmpl.dmpl.FnPrototypeDeclaration;
import edu.cmu.sei.annex.dmpl.dmpl.IdDimension;
import edu.cmu.sei.annex.dmpl.dmpl.IdExpr;
import edu.cmu.sei.annex.dmpl.dmpl.IntConst;
import edu.cmu.sei.annex.dmpl.dmpl.IntDimension;
import edu.cmu.sei.annex.dmpl.dmpl.IntExpr;
import edu.cmu.sei.annex.dmpl.dmpl.LVal;
import edu.cmu.sei.annex.dmpl.dmpl.MultiplicativeExpr;
import edu.cmu.sei.annex.dmpl.dmpl.NodeNumDimension;
import edu.cmu.sei.annex.dmpl.dmpl.NodeNumExpr;
import edu.cmu.sei.annex.dmpl.dmpl.Param;
import edu.cmu.sei.annex.dmpl.dmpl.ProcNoAttr;
import edu.cmu.sei.annex.dmpl.dmpl.Procedure;
import edu.cmu.sei.annex.dmpl.dmpl.Program;
import edu.cmu.sei.annex.dmpl.dmpl.ThreadDeclaration;
import edu.cmu.sei.annex.dmpl.dmpl.Type;
import edu.cmu.sei.annex.dmpl.dmpl.UnaryExpr;
import edu.cmu.sei.annex.dmpl.dmpl.Var;
import edu.cmu.sei.annex.dmpl.dmpl.VarAsgn;
import edu.cmu.sei.annex.dmpl.dmpl.VarAsgnList;
import edu.cmu.sei.annex.dmpl.dmpl.VarInit;
import edu.cmu.sei.annex.dmpl.dmpl.VarInitList;
import edu.cmu.sei.annex.dmpl.services.DmplGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DmplSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DmplGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == DmplPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case DmplPackage.ARG_LIST:
				sequence_ArgList(context, (ArgList) semanticObject); 
				return; 
			case DmplPackage.BUILT_IN_EXPR:
				sequence_TerminalExpr(context, (BuiltInExpr) semanticObject); 
				return; 
			case DmplPackage.CALL_EXPR:
				sequence_CallExpr(context, (CallExpr) semanticObject); 
				return; 
			case DmplPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case DmplPackage.DMPL_SUBCLAUSE:
				sequence_DmplSubclause(context, (DmplSubclause) semanticObject); 
				return; 
			case DmplPackage.DOUBLE_CONST:
				sequence_DoubleConst(context, (DoubleConst) semanticObject); 
				return; 
			case DmplPackage.DOUBLE_EXPR:
				sequence_TerminalExpr(context, (DoubleExpr) semanticObject); 
				return; 
			case DmplPackage.FN_BODY:
				sequence_FnBody(context, (FnBody) semanticObject); 
				return; 
			case DmplPackage.FN_PROTOTYPE_DECLARATION:
				sequence_FnPrototype(context, (FnPrototypeDeclaration) semanticObject); 
				return; 
			case DmplPackage.ID_DIMENSION:
				sequence_Dimension(context, (IdDimension) semanticObject); 
				return; 
			case DmplPackage.ID_EXPR:
				sequence_TerminalExpr(context, (IdExpr) semanticObject); 
				return; 
			case DmplPackage.INT_CONST:
				sequence_IntConst(context, (IntConst) semanticObject); 
				return; 
			case DmplPackage.INT_DIMENSION:
				sequence_Dimension(context, (IntDimension) semanticObject); 
				return; 
			case DmplPackage.INT_EXPR:
				sequence_TerminalExpr(context, (IntExpr) semanticObject); 
				return; 
			case DmplPackage.LVAL:
				sequence_LVal(context, (LVal) semanticObject); 
				return; 
			case DmplPackage.MULTIPLICATIVE_EXPR:
				sequence_MultiplicativeExpr(context, (MultiplicativeExpr) semanticObject); 
				return; 
			case DmplPackage.NODE_NUM_DIMENSION:
				sequence_Dimension(context, (NodeNumDimension) semanticObject); 
				return; 
			case DmplPackage.NODE_NUM_EXPR:
				sequence_TerminalExpr(context, (NodeNumExpr) semanticObject); 
				return; 
			case DmplPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case DmplPackage.PROC_NO_ATTR:
				sequence_ProcNoAttr(context, (ProcNoAttr) semanticObject); 
				return; 
			case DmplPackage.PROCEDURE:
				sequence_Procedure(context, (Procedure) semanticObject); 
				return; 
			case DmplPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case DmplPackage.THREAD_DECLARATION:
				sequence_FnPrototype(context, (ThreadDeclaration) semanticObject); 
				return; 
			case DmplPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case DmplPackage.UNARY_EXPR:
				sequence_TerminalExpr(context, (UnaryExpr) semanticObject); 
				return; 
			case DmplPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case DmplPackage.VAR_ASGN:
				sequence_VarAsgn(context, (VarAsgn) semanticObject); 
				return; 
			case DmplPackage.VAR_ASGN_LIST:
				sequence_VarAsgnList(context, (VarAsgnList) semanticObject); 
				return; 
			case DmplPackage.VAR_INIT:
				sequence_VarInit(context, (VarInit) semanticObject); 
				return; 
			case DmplPackage.VAR_INIT_LIST:
				sequence_VarInitList(context, (VarInitList) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     ((args+=Expr args+=Expr*)?)
	 */
	protected void sequence_ArgList(EObject context, ArgList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (namespace=TIDENTIFIER? name=TIDENTIFIER argList=ArgList at=Expr?)
	 */
	protected void sequence_CallExpr(EObject context, CallExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER value=NumberConst)
	 */
	protected void sequence_Constant(EObject context, Constant semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.CONSTANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.CONSTANT__NAME));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.CONSTANT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConstantAccess().getNameTIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstantAccess().getValueNumberConstParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     index=TIDENTIFIER
	 */
	protected void sequence_Dimension(EObject context, IdDimension semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.ID_DIMENSION__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.ID_DIMENSION__INDEX));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDimensionAccess().getIndexTIDENTIFIERTerminalRuleCall_2_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     index=INT
	 */
	protected void sequence_Dimension(EObject context, IntDimension semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.INT_DIMENSION__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.INT_DIMENSION__INDEX));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDimensionAccess().getIndexINTTerminalRuleCall_0_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {NodeNumDimension}
	 */
	protected void sequence_Dimension(EObject context, NodeNumDimension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     program=Program
	 */
	protected void sequence_DmplSubclause(EObject context, DmplSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sign=Sign? value=Double)
	 */
	protected void sequence_DoubleConst(EObject context, DoubleConst semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     varInitList=VarInitList
	 */
	protected void sequence_FnBody(EObject context, FnBody semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.FN_BODY__VAR_INIT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.FN_BODY__VAR_INIT_LIST));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFnBodyAccess().getVarInitListVarInitListParserRuleCall_1_0(), semanticObject.getVarInitList());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((extern?='extern' | extern?='EXTERN')? (pure?='pure' | pure?='PURE')? type=Type name=TIDENTIFIER (params+=Param params+=Param*)?)
	 */
	protected void sequence_FnPrototype(EObject context, FnPrototypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((extern?='extern' | extern?='EXTERN')? (pure?='pure' | pure?='PURE')? name=TIDENTIFIER)
	 */
	protected void sequence_FnPrototype(EObject context, ThreadDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sign=Sign? value=INT)
	 */
	protected void sequence_IntConst(EObject context, IntConst semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER indices+=Expr* at=Expr?)
	 */
	protected void sequence_LVal(EObject context, LVal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=MultiplicativeExpr_MultiplicativeExpr_1_0_0_0 operator=MultiplicativeOperator right=TerminalExpr)
	 */
	protected void sequence_MultiplicativeExpr(EObject context, MultiplicativeExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.MULTIPLICATIVE_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getMultiplicativeExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getOperatorMultiplicativeOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getRightTerminalExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type var=Var)
	 */
	protected void sequence_Param(EObject context, Param semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.PARAM__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.PARAM__TYPE));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.PARAM__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.PARAM__VAR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParamAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParamAccess().getVarVarParserRuleCall_1_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (prototype=FnPrototype fnBody=FnBody?)
	 */
	protected void sequence_ProcNoAttr(EObject context, ProcNoAttr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     procedure=ProcNoAttr
	 */
	protected void sequence_Procedure(EObject context, Procedure semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.PROCEDURE__PROCEDURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.PROCEDURE__PROCEDURE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProcedureAccess().getProcedureProcNoAttrParserRuleCall_0(), semanticObject.getProcedure());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (programElements+=ProgramElement*)
	 */
	protected void sequence_Program(EObject context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (function=BuiltInFunction firstArg=TIDENTIFIER secondArg=Expr)
	 */
	protected void sequence_TerminalExpr(EObject context, BuiltInExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__FUNCTION));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__FIRST_ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__FIRST_ARG));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__SECOND_ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.BUILT_IN_EXPR__SECOND_ARG));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalExprAccess().getFunctionBuiltInFunctionParserRuleCall_6_1_0(), semanticObject.getFunction());
		feeder.accept(grammarAccess.getTerminalExprAccess().getFirstArgTIDENTIFIERTerminalRuleCall_6_3_0(), semanticObject.getFirstArg());
		feeder.accept(grammarAccess.getTerminalExprAccess().getSecondArgExprParserRuleCall_6_5_0(), semanticObject.getSecondArg());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=Double
	 */
	protected void sequence_TerminalExpr(EObject context, DoubleExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.DOUBLE_EXPR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.DOUBLE_EXPR__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalExprAccess().getValueDoubleParserRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {IdExpr}
	 */
	protected void sequence_TerminalExpr(EObject context, IdExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_TerminalExpr(EObject context, IntExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.INT_EXPR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.INT_EXPR__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalExprAccess().getValueINTTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {NodeNumExpr}
	 */
	protected void sequence_TerminalExpr(EObject context, NodeNumExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (operator=UnaryOperator operand=Expr)
	 */
	protected void sequence_TerminalExpr(EObject context, UnaryExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.UNARY_EXPR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.UNARY_EXPR__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.UNARY_EXPR__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.UNARY_EXPR__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalExprAccess().getOperatorUnaryOperatorEnumRuleCall_5_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getTerminalExprAccess().getOperandExprParserRuleCall_5_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (signed=Signed? simpType=SimpType)
	 */
	protected void sequence_Type(EObject context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (var=Var | varAsgn=VarAsgn)
	 */
	protected void sequence_VarAsgnList(EObject context, VarAsgnList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (var=Var (fnBody=FnBody | expr=Expr))
	 */
	protected void sequence_VarAsgn(EObject context, VarAsgn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (varInits+=VarInit*)
	 */
	protected void sequence_VarInitList(EObject context, VarInitList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type varAsgnList=VarAsgnList)
	 */
	protected void sequence_VarInit(EObject context, VarInit semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.VAR_INIT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.VAR_INIT__TYPE));
			if(transientValues.isValueTransient(semanticObject, DmplPackage.Literals.VAR_INIT__VAR_ASGN_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmplPackage.Literals.VAR_INIT__VAR_ASGN_LIST));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVarInitAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVarInitAccess().getVarAsgnListVarAsgnListParserRuleCall_1_0(), semanticObject.getVarAsgnList());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=TIDENTIFIER dimensions+=Dimension*)
	 */
	protected void sequence_Var(EObject context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
